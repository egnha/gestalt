% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache.R
\name{cache}
\alias{cache}
\alias{uncache}
\title{Cache the value of a void function call}
\usage{
cache(f)

uncache(f)
}
\arguments{
\item{f}{Function, or symbol or name (string) thereof, that can be called
without arguments. (NB: \code{cache()} itself does not check whether \code{f()} is
indeed a valid call.)}
}
\value{
\code{cache()} returns a function without formal arguments that returns
the (cached) value of the void call \code{f()}. \code{uncache()} recovers the
underlying (uncached) function of a cached function.
}
\description{
\code{cache()} is a convenience helper that transforms a function into a function
that caches the value of its \emph{void call}, i.e., \code{cache()}
\href{https://en.wikipedia.org/wiki/Memoization}{memoizes} void functions. Use
\code{cache()} when you want to treat a computed value as a \emph{constant} with
\dQuote{structure,} namely the computation that produced it.
}
\examples{
# Function with constant return value
val <- {message("Computing from scratch"); mtcars} \%>>>\%
  split(.$cyl) \%>>>\%
  lapply(function(data) lm(mpg ~ wt, data)) \%>>>\%
  lapply(summary) \%>>>\%
  sapply(`[[`, "r.squared")

# Caching `val` ensures that its value is computed only once.
# On subsequent calls, the computed value is simply fetched:
val_cached <- cache(val)
val_cached()
val_cached()
val()
val()

# As values, `val()` and `val_cached()` are identical.
# But `val_cached()` also has structure, namely the function `val_cached`:
val_cached

# For instance, you can inspect the intermediate summary:
head(val_cached, -1)()

\dontrun{
# You can think of `\%>>>\%` combined with `cache()` as a lazy, structured
# alternative to the magrittr `\%>\%`.

require(magrittr)

val2 <- mtcars \%>\%
  split(.$cyl) \%>\%
  lapply(function(data) lm(mpg ~ wt, data)) \%>\%
  lapply(summary) \%>\%
  sapply(`[[`, "r.squared")

# `val2` and `val()` are identical values. But in contrast to `val_cached()`,
# the “structure” of `val2` is only implicit in source code.
stopifnot(identical(val2, val_cached()))}

# Use `uncache()` to recover the uncached function
val_uncached <- uncache(val_cached)
stopifnot(identical(uncache(val_cached), val))
val_uncached()
val_uncached()

}
\seealso{
\code{\link[=compose]{\%>>>\%}}
}
