% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deprecated.R
\name{deprecated}
\alias{deprecated}
\alias{as_fn}
\alias{make_fn_aware}
\alias{as_fn}
\alias{make_fn_aware}
\alias{curry}
\alias{curry_fn}
\title{Deprecated functions}
\usage{
as_fn(.f)

make_fn_aware(f, ...)

curry(f, env = environment(f))

curry_fn(..., ..env = parent.frame())
}
\arguments{
\item{.f}{A function or an abbreviated anonymous-function expression of the
form \code{.(...)}, where \code{...} is a \link[=fn]{function declaration} (i.e., \code{.}
(dot) in this context is an alias of \code{\link[=fn]{fn()}}).
\link[rlang:quasiquotation]{Quasiquotation} is supported.}

\item{f}{\code{make_fn_aware()}: Function, or symbol or name of a function;
\code{curry()}: Function.}

\item{...}{\code{make_fn_aware()}: Name(s) of functional argument(s) of \code{f}
(strings) or \code{NULL}. Unsplicing of lists of strings is supported via \code{!!!};
\code{curry_fn()}: Function declaration, which supports
\link[rlang:quasiquotation]{quasiquotation}.}

\item{env}{Environment of the curried function or \code{NULL}. If \code{NULL}, the
environment of the curried function is the calling environment.}

\item{..env}{Environment in which to create the function (i.e., the
function’s \link[base:environment]{enclosing environment}).}
}
\value{
\code{as_fn()}: If \code{.f} is a function, it is simply returned, otherwise
the function determined by the \link[=fn]{function declaration} is returned.

\code{make_fn_aware()}: A function with the same call signature as \code{f},
but whose function arguments, as designated by \code{...}, may be specified
using an abbreviated function expression of the form \code{.(...)}, cf.
\code{\link[=as_fn]{as_fn()}}. If \code{...} is empty or \code{NULL}, then \code{f} is simply returned.

\code{curry()}, \code{curry_fn()}: A function of nested single-argument
functions.
}
\description{
These functions are softly deprecated and may be removed from a future
version of \pkg{nofrills}. They were intended to enable a shorter
\code{fn()}-syntax for higher-order functions—a negligible convenience. Instead,
simply invoke \code{fn()} directly.
}
\details{
\code{as_fn()} is for functions that take functional arguments. Use
\code{as_fn()} \emph{inside} a function to enable it to comprehend a minimal
anonymous-function notation for arguments that are functions. This notation
is that of \code{\link[=fn]{fn()}}, but with \sQuote{\code{fn}} replaced by \sQuote{\code{.}} (dot).
\code{as_fn()} cannot follow promise expressions across function calls. It is
only intended to work in the immediate context in which a function
declaration is to be interpreted (see \emph{Examples}).

\code{make_fn_aware()} is a functional operator that enhances a function
by enabling it to interpret abbreviated functional arguments.

\code{curry()} \href{https://en.wikipedia.org/wiki/Currying}{curries}
functions—it reconstitutes a function as a succession of single-argument
functions. For example, \code{curry()} produces the the function\preformatted{function(x) {
  function(y) {
    function(z) {
      x * y * z
    }
  }
}
}

from the function \code{function(x, y, z) x * y * z}. Dots (\code{...}) are treated
as a unit when currying. For example, \code{curry()} transforms \code{function(x, ...) list(x, ...)} to \code{function(x) { function(...) list(x, ...) }}.

\code{curry_fn()} produces a curried function from an \code{\link[=fn]{fn()}}-style
function declaration, which supports
\link[rlang:quasiquotation]{quasiquotation} of a function’s body and (default)
argument values.
}
\examples{
\dontrun{
call_fn <- function(.f, x) {
  f <- as_fn(.f)
  f(x)
}
call_fn(log, 1)
call_fn(.(. ~ sin(.) ^ 2), 1)
# simplified function expressions support quasiquotation
f <- sin
call_fn(.(. ~ (!!f)(.) ^ 2), 1)

## wrap Map() to accept abbreviated anonymous function expressions
Map_ <- function (f, ...) {
  f <- as_fn(f)
  mapply(FUN = f, ..., SIMPLIFY = FALSE)
}
# you can call Map_() just like Map()
Map_(function(x, y, z) paste(x, y, paste("and", z), sep = ", "), 1:3, 4:6, 7:9)
# or use a simplified function expression
Map_(.(x, y, z ~ paste(x, y, paste("and", z), sep = ", ")), 1:3, 4:6, 7:9)

## abbreviated anonymous functions are interpreted in the calling environment
# so this works, as expected
foo <- function(a) as_fn(a)
foo(.(x ~ x + 1))
# but as_fn() can't interpret abbreviated anonymous functions across calls
foo <- function(a) bar(a)
bar <- function(b) as_fn(b)
foo(.(x ~ x + 1))
}

\dontrun{
reduce <- make_fn_aware(Reduce, "f")

## reduce() behaves just like Reduce()
Reduce(function(u, v) u + 1 / v, c(3, 7, 15, 1, 292), right = TRUE)
reduce(function(u, v) u + 1 / v, c(3, 7, 15, 1, 292), right = TRUE)

## reduce() can also interpret abbreviated function expressions
reduce(.(u, v ~ u + 1 / v), c(3, 7, 15, 1, 292), right = TRUE)
}

\dontrun{
curry(function(x, y, z = 0) x + y + z)
double <- curry(`*`)(2)
double(3)  # 6
}

\dontrun{
curry_fn(x, y, z = 0 ~ x + y + z)
curry_fn(target, ... ~ identical(target, ...))

## Delay unquoting to embed argument values into the innermost function
compare_to <- curry_fn(target, x ~ identical(x, QUQ(target)))
is_this <- compare_to("this")
is_this("that")  # FALSE
is_this("this")  # TRUE
classify_as <- curry_fn(class, x ~ `class<-`(x, QUQ(class)))
as_this <- classify_as("this")
as_this("Some object")  # String of class "this"
}

}
\seealso{
\code{\link[=fn]{fn()}}, \code{\link[=partial]{partial()}}
}
\keyword{internal}
