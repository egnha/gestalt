% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compose.R
\name{compose}
\alias{compose}
\alias{\%>>>\%}
\title{Compose functions}
\usage{
compose(...)

inner \%>>>\% outer
}
\arguments{
\item{...}{Functions or lists thereof to compose. Lists of functions are
automatically spliced in. \link[rlang:quasiquotation]{Unquoting} of names, via
\code{!!} on the left-hand side of \code{:=}, and \link[rlang:quasiquotation]{splicing},
via \code{!!!}, are supported.}

\item{inner, outer}{Functions. These may be optionally named using \code{:}, e.g.,
\code{f \%>>>\% nm: g} names the \code{g}-component.
\link[rlang:quasiquotation]{Quasiquotation} and the
\href{https://cran.r-project.org/package=magrittr}{\pkg{magrittr}}-\code{\%>\%}
semantics are supported (see \emph{Examples}).}
}
\value{
A function composition, whose \link[base:formals]{formals} match those
of the inner function applied (as a closure).
}
\description{
Compose functions in two ways:
\itemize{
\item Use \code{compose(f, g, ...)} to make the function that applies \code{f}, then \code{g},
etc. It has the \link[base:formals]{formals} of the “inner” function \code{f}.
Thus
\preformatted{compose(paste, toupper)}
is equivalent to the function\preformatted{function(..., sep = " ", collapse = NULL) {
  toupper(paste(..., sep = sep, collapse = collapse))
}
}
\item Alternatively, use the infix notation \code{f \%>>>\% g \%>>>\% ...}, which
comprehends the semantics of the
\href{https://cran.r-project.org/package=magrittr}{\pkg{magrittr}}-\code{\%>\%}
operator and, additionally, \link[rlang:quasiquotation]{quasiquotation}.
Thus, assuming \code{sep} has the value \code{""},
\preformatted{sample \%>>>\% paste(collapse = !!sep)}
is equivalent to the function\preformatted{function(x, size, replace = FALSE, prob = NULL) {
  paste(sample(x, size, replace, prob), collapse = "")
}
}
}

Use \code{as.list()} to recover the list of composite functions.
}
\section{Properties}{
 \code{compose()} is \emph{associative}, semantically and
operationally. This means, for instance, that
\code{compose(f, g, h)},
\code{compose(f, compose(g, h))},
\code{compose(compose(f, g), h)},
are implemented as the \emph{same function}. In other words, lists of functions
are automatically “flattened out” when they are composed—intermediate
compositions are spliced rather than nested.

\code{as.list()} and \code{compose()} are \emph{mutually invertible}.
\code{as.list(compose(fs))} is the same as \code{fs}, when \code{fs} is a list of
functions (though the names of \code{as.list()} are always strings).
}

\examples{
# Functions are composed from right to left (following convention)
inv <- partial(`/`, 1)  # reciprocal
f0 <- compose(abs, log, inv)
stopifnot(all.equal(f0(-2), 1 / log(abs(-2))))

# Forward composition operator composes from left to right
f1 <- abs \%>>>\% log \%>>>\% {1 / .}
stopifnot(all.equal(f1(-2), f0(-2)))

# Compose higher-order functions
\dontrun{
# Transforms function to a JSON function
require(jsonlite)
jsonify <- {fromJSON \%>>>\% .} \%>>>\% {. \%>>>\% toJSON}
jsonify <- fn(f ~ fromJSON \%>>>\% f \%>>>\% toJSON)}

# Formals of initial function are preserved
inner <- function(a, b = 0) a + b
stopifnot(identical(formals(compose(inner, inv)), formals(inner)))

# Compositions can be provided by lists, in several equivalent ways
f2 <- compose(list(abs, log, inv))
f3 <- compose(!!! list(abs, log, inv))
f4 <- compose(abs, list(log, inv))
f5 <- compose(abs, !!! list(log, inv))
stopifnot(
  all.equal(f2, f0), all.equal(f2(-2), f0(-2)),
  all.equal(f3, f0), all.equal(f3(-2), f0(-2)),
  all.equal(f4, f0), all.equal(f4(-2), f0(-2)),
  all.equal(f5, f0), all.equal(f5(-2), f0(-2))
)

# compose() and as.list() are mutally invertible
f6 <- compose(abs, as.list(compose(log, inv)))
stopifnot(
  all.equal(f6, f0), all.equal(f6(-2), f0(-2))
)
fs <- list(abs, log, inv)
stopifnot(all.equal(check.attributes = FALSE,
  as.list(compose(fs)), fs,
))

# `\%>>>\%` supports names, magrittr-`\%>\%` semantics, quasiquotation
sep <- ""
scramble <- shuffle: sample \%>>>\% paste(collapse = !!sep)
nonsense <- scramble(letters)
stopifnot(
  nchar(nonsense) == 26L,
  identical(letters, sort(strsplit(nonsense, sep)[[1]])),
  identical(scramble$shuffle, sample)
)

}
